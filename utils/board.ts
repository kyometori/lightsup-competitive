
import { BoardState } from '../types.ts';

const BOARD_SIZE = 5;

// Mulberry32 algorithm
const createPRNG = (seed: number) => {
  return () => {
    let t = seed += 0x6D2B79F5;
    t = Math.imul(t ^ t >>> 15, t | 1);
    t ^= t + Math.imul(t ^ t >>> 7, t | 61);
    return ((t ^ t >>> 14) >>> 0) / 4294967296;
  }
}

// Function to hash a string seed into a number
const hashString = (str: string): number => {
    let hash = 0;
    if (str.length === 0) return Math.random() * 2**32;
    for (let i = 0; i < str.length; i++) {
        const char = str.charCodeAt(i);
        hash = ((hash << 5) - hash) + char;
        hash |= 0; // Convert to 32bit integer
    }
    return hash;
}

/**
 * Creates a PRNG function from a string seed.
 */
export const createSeededPRNG = (seed: string): (() => number) => {
    return createPRNG(hashString(seed));
}

/**
 * Creates a new board of a given size, with all cells set to a specific state.
 */
export const createInitialBoard = (state: boolean): BoardState => {
  return Array(BOARD_SIZE).fill(null).map(() => Array(BOARD_SIZE).fill(state));
};

/**
 * Toggles a cell and its adjacent neighbors. Returns a new board state.
 */
export const toggleCellAndNeighbors = (board: BoardState, r: number, c: number): BoardState => {
  const newBoard = board.map(row => [...row]);
  const directions = [[0, 0], [0, 1], [0, -1], [1, 0], [-1, 0]];

  directions.forEach(([dr, dc]) => {
    const newR = r + dr;
    const newC = c + dc;

    if (newR >= 0 && newR < BOARD_SIZE && newC >= 0 && newC < BOARD_SIZE) {
      newBoard[newR][newC] = !newBoard[newR][newC];
    }
  });

  return newBoard;
};

/**
 * Checks if two boards have the exact same state.
 */
export const areBoardsEqual = (boardA: BoardState, boardB: BoardState): boolean => {
  for (let r = 0; r < BOARD_SIZE; r++) {
    for (let c = 0; c < BOARD_SIZE; c++) {
      if (boardA[r][c] !== boardB[r][c]) {
        return false;
      }
    }
  }
  return true;
};

/**
 * Creates a solvable puzzle by starting with a solved board (all on) and applying a series of random "clicks".
 * Each cell has a 50% chance of being clicked. This ensures a uniform distribution over all possible board states.
 * The function ensures the generated board is not trivial (i.e., not fully on, not fully off, and generated by a reasonable number of clicks).
 */
export const generateSolvableBoard = (prng: () => number = Math.random): BoardState => {
  let board: BoardState;
  let isTrivial: boolean;

  // Min clicks to be considered non-trivial. Average is 12.5.
  const MIN_CLICKS = 5; 

  do {
    board = createInitialBoard(true); // Start with a solved board
    let clickCount = 0;

    for (let r = 0; r < BOARD_SIZE; r++) {
      for (let c = 0; c < BOARD_SIZE; c++) {
        if (prng() < 0.5) {
          board = toggleCellAndNeighbors(board, r, c);
          clickCount++;
        }
      }
    }

    const isSolved = areBoardsEqual(board, createInitialBoard(true));
    // The "all off" state is another simple pattern to solve from.
    const isAllOff = board.every(row => row.every(cell => !cell));
    
    isTrivial = isSolved || isAllOff || clickCount < MIN_CLICKS;

  } while (isTrivial);

  return board;
};